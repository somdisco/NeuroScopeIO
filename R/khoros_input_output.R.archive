#' Read a khoros header file
#'
#' Information about the image cube is stored in the proprietary Khoros header format.  This function reads that header
#' and extracts the relevant characteristics needed to read the binary image cube.  Note that this can only parse viff
#' files (not kdf format; if you have kdf you must convert in Khoros with \code{kformats})
#'
#' @param filename string specifying the file path & name of the khoros viff cube
#'
#' @return list with components:
#' \itemize{
#'    \item imgEndian = string, either 'little' or 'big'
#'    \item imgW = integer, width of image in pixels
#'    \item imgH = integer, height of image in pixels
#'    \item imgB = integer, number of image bands
#'    \item imgT = string, image data type ('double', 'integer', etc) \cr
#'          Note that this data type is for R's \code{readBin} function.
#'    \item imgTsize = integer, size of data type in bytes
#'    \item imgTsigned = boolean, TRUE for signed data
#' }
#'
#' @examples
#' read_khoros_header('8class-caseI-n_m0v5.viff')
#'
#' @export
read_khoros_header = function(filename) {

  # initialize the vars
  viff = TRUE;
  imgE = -1;
  imgW = -1;
  imgH = -1;
  imgB = -1;
  imgT = -1;

  ### Open the file for reading
  fid = file(filename, "rb")

  ### Read header
  FileId   = readBin(con = fid, what = 'int', n = 1, size = 1, signed = F, endian = 'little')
  FileType = readBin(con = fid, what = 'int', n = 1, size = 1, signed = F, endian = 'little')
  if(FileId == 171 && FileType == 01) {
    viff = TRUE;
  } else {
    viff = TRUE;
    stop('readViffHead: file is not viff (xv) formatted');
    close(fid)
  }

  ### Skip 2 elements
  readBin(con = fid, what = 'raw', n = 2, size = 1)

  ### Set the endianness
  MachineDep = readBin(con = fid, what = 'int', n = 1, size = 1, signed = F, endian = 'little')
  if(MachineDep == 8) {
    imgE = 'little'
  } else if(MachineDep == 2) {
    imgE = 'big'
  } else {
    viff = FALSE
    stop('readViffHead: Cannot find endianness')
    close(fid)
  }

  ### Skip 515 elements
  readBin(con = fid, what = 'raw', n = 515, size = 1)

  ### Set the image width, height
  imgW = readBin(con = fid, what = 'integer', n = 1, size = 4, endian = imgE)
  imgH = readBin(con = fid, what = 'integer', n = 1, size = 4, endian = imgE)

  ### Skip 32 elements
  readBin(con = fid, what = 'raw', n = 32, size = 1)

  ### Set the number of bands
  imgB = readBin(con = fid, what = 'integer', n = 1, size = 4, endian = imgE)

  ### Set the data storage type
  DataStorageType = readBin(con = fid, what = 'integer', n = 1, size = 4, endian = imgE)
  if(DataStorageType == 0) {
    imgT = 'raw'; imgTsize = 1; imgTsigned = FALSE;
  } else if(DataStorageType == 1) {
    imgT = 'int'; imgTsize = 1; imgTsigned = FALSE;
  } else if(DataStorageType == 2) {
    imgT = 'int'; imgTsize = 2; imgTsigned = TRUE;
  } else if(DataStorageType == 4) {
    imgT = 'integer'; imgTsize = 4; imgTsigned = TRUE;
  } else if(DataStorageType == 5) {
    imgT = 'numeric'; imgTsize = 4; imgTsigned = TRUE;
  } else if(DataStorageType == 6) {
    stop('readViffHead: Cannot import complex type')
  } else if(DataStorageType == 9) {
    imgT = 'double'; imgTsize = 8; imgTsigned = TRUE;
  } else if(DataStorageType == 10) {
    stop('readViffHead: Cannot import complex type')
  } else {
    viff = FALSE
    stop('readViffHead: Cannot find data type')
    close(fid)
  }

  ### Skip to end
  readBin(con = fid, what = 'raw', n = 456, size = 1)

  ### Close file
  close(fid)

  ### Return
  out = NULL
  out$imgEndian = imgE
  out$imgW = imgW
  out$imgH = imgH
  out$imgB = imgB
  out$imgT = imgT
  out$imgTsize = imgTsize
  out$imgTsigned = imgTsigned

  return(out)
}



#' Import a Khoros cube in viff format
#'
#' The header will be read to obtain the pertinent information required for reading the binary image cube:  image width & height, number of image bands, etc.  The actual reading is done with \code{readBin}.
#'
#' @param filename string specifying the file path & name of the khoros viff cube
#'
#' @return a 3-dimensional array whose [i,j,k] entry represents the value in row i, column j and band k of the image cube.
#'
#' @examples
#'
#' @export
read_khoros_cube = function(filename) {
  ### filename is string (path + filename) to viff file
  ### img_width & img_height are number of pixels in image
  ### n_dim is integer specifying number of dimensions / bands of data cube
  ### data_type is one of "FLOAT","SHORT","DOUBLE" which tells what precision the data are stored in
  ### header_bytes gives number of bytes in header.  If NULL, we will determine this programatically
  ### endian = 'little' or 'big' indicates endian-ness of file
  ### output_type is one of "cube" or "matrix", indicating whether to return the data as a 3d array or a 2d data matrix

  ### ****** Attempt to read the Khoros header file to detrmine image characteristics ******
  ### If error, then we can't read the file
  hdr = NULL
  hdr = read_khoros_header(filename)
  if(is.null(hdr)) stop('Cannot read Khoros header file.  Exiting.')

  ### Extract the image characteristics
  endian = hdr$imgEndian
  img_width = hdr$imgW
  img_height = hdr$imgH
  n_dim = hdr$imgB
  datatype = hdr$imgT
  num_bytes_per_datum = hdr$imgTsize
  signed = hdr$imgTsigned

  num_pixels = img_width * img_height
  num_data_bytes = num_pixels * n_dim * num_bytes_per_datum

  ### ****** Initialize connection to file and read past header ******
  to.read = file(filename, "rb")
  readBin(con = to.read, what = 'raw', n = 1024, size = 1)

  ### ****** Initialize cube array and fill it up ******
  outcube = array(NA, dim = c(img_height, img_width, n_dim))
  for(i in 1:n_dim) {
    dimvec = readBin(con = to.read, what = datatype, n = img_width*img_height, size = num_bytes_per_datum, signed = signed, endian = endian)
    outcube[,,i] = matrix(dimvec, nrow = img_height, ncol = img_width, byrow = T)
  }
  close(to.read)

  ### ****** Write the NW,NE,SW,SE corners of the image cube to the console window
  cat(sprintf('NW corner of cube: \n'))
  cat(sprintf('%6f',outcube[1,1,]))
  cat(sprintf('\nNE corner of cube:\n'))
  cat(sprintf('%6f',outcube[1,img_width,]))
  cat(sprintf('\nSW corner of cube:\n'))
  cat(sprintf('%6f',outcube[img_height,1,]))
  cat(sprintf('\nSE corner of cube:\n'))
  cat(sprintf('%6f',outcube[img_height,img_width,]))


  return(outcube)
}



#' Reading and processing a Khoros include file
#'
#' Include files contain information on which parts of the image cube are masked (i.e., pixels that should be ignored) as well as the class designation of each pixel, if available.
#'
#' @param filename string specifying the file path & name of the include file
#' @param img_width integer, width of image in pixels
#' @param img_height integer, height of image in pixels
#'
#' @return a list with components:
#' \itemize{
#'   \item mask:  an img_height x img_width boolean matrix whose [i,j] entry specifies whether the pixel in row i, column j of the image should be masked.
#'   \item class:  an img_height x img_width character matrix whose [i,j] entry defines the class label of the pixel in row i, column j of the image.  Due to Khoros limitations, the available classes are A-Z,a-z plus some other special characters.\cr
#'                 Note:  labeling of all pixels in the include file is not mandatory.  If no class information is found, NA will be returned.
#' }
#'
#' @examples
#' read_khoros_includefile('8class-caseI-all.incl', 15, 15)
#'
#' @export
read_khoros_includefile = function(filename, img_width, img_height) {

  ### filename = string of file path name
  ### img_width & img_height are integers denoting # of pixels in each dim of image
  ### output_type is either "matrix" or "vector", indicating whether the results should be returned
  ###    as a mat or a vec.  If vec, the order will be starting from the NW corner to the SE corner, reading
  ###    left to right

  num_pixels = img_width * img_height

  ### ****** Read include file into character vector ******
  ### Each entry in the vector represents one line in the include file
  incl = readLines(filename)

  ### ****** Remove comments ******
  ### If any element contains a # (comment character), remove everything in that line after it
  comment_start_pos = stringr::str_locate(incl,"#")[,1]
  idx_to_change = which(!is.na(comment_start_pos))
  incl[idx_to_change] = stringr::str_sub(incl[idx_to_change], start = rep(1,length(idx_to_change)), end = comment_start_pos[idx_to_change]-1)

  ### ****** Remove any empty lines ******
  line_lengths = stringr::str_length(incl)
  incl = incl[-which(line_lengths==0)]

  ### ****** Remove any duplicate whitespace ******
  incl = stringr::str_replace_all(incl, pattern = "\\s+", replacement = " ")

  ### ****** Trim any leading / trailing whitespace ******
  incl = stringr::str_trim(incl, side='both')

  ### ****** Split each line into components
  ### Since include files lines are something like "include area x1 y1 x2 y2 CLASS"
  ### we will split on spaces and ask for 7 columns in the resulting matrix
  ### If the CLASS field is missing, str_split_fixed will return a "" in the last column.
  ### In that case, overwrite the "" with "?"
  incl = stringr::str_split_fixed(incl, pattern = " ", 7)
  incl[incl==""] = "?"

  ### The columns of this matrix are now something like "include","area","x1","y1","x2","y2","CLASS"
  ### Drop the 2nd column since it's not informative.
  ### The columns will now be "include","x1","y1","x2","y2","CLASS"
  incl = incl[,-2]

  ### ****** Create the mask and class sets ******
  ### mask will be a img_height x img_width boolean matrix, where mask[i,j] = TRUE corresponds to "exclude" pixels
  ### and mask[i,j] = FALSE corresponds to "include" pixels
  mask = matrix(FALSE, nrow = img_height, ncol = img_width)
  classmat = matrix(NA, nrow = img_height, ncol = img_width)
  for(i in 1:nrow(incl)) {
    thisgroup = expand.grid(incl[i,3]:incl[i,5], incl[i,2]:incl[i,4])
    thisgroup = as.matrix(thisgroup)

    if(incl[i,1]=='exclude') mask[thisgroup] = TRUE

    classmat[thisgroup] = incl[i,6]
  }

  out = NULL
  out$mask = mask
  out$class = classmat

  return(out)
}



#' Reading and processing a Khoros color table file
#'
#' Color tables specify the RGB codes for the classes defined in either the include file or remap.
#'
#' @param filename string specifying the file path & name of the color table file
#'
#' @return a data frame with columns:
#' \itemize{
#'   \item class:  a character vector defining the class label (see ?read_khoros_includefile for more information on possible class label characters)
#'   \item R:  an integer vector in [0-255] defining the red plane of the class color
#'   \item G:  an integer vector in [0-255] defining the green plane of the class color
#'   \item B:  an integer vector in [0-255] defining the blue plane of the class color
#' }
#'
#' @examples
#' read_khoros_ctab('6d-synthetic_30.ctab')
#'
#' @export
read_khoros_ctab = function(filename) {
  ctab = readLines(filename)

  ### ****** Remove comments ******
  ### If any element contains a # (comment character), remove everything in that line after it
  comment_start_pos = stringr::str_locate(ctab,"#")[,1]
  idx_to_change = which(!is.na(comment_start_pos))
  ctab[idx_to_change] = stringr::str_sub(ctab[idx_to_change], start = rep(1,length(idx_to_change)), end = comment_start_pos[idx_to_change]-1)

  ### ****** Remove the "color_table" and "end color_table" declarations ******
  ctab = stringr::str_replace(ctab, pattern = "end color_table", replacement = "")
  ctab = stringr::str_replace(ctab, pattern = "color_table", replacement = "")

  ### ****** Remove any empty lines ******
  line_lengths = stringr::str_length(ctab)
  ctab = ctab[-which(line_lengths==0)]

  ### ****** Remove any duplicate whitespace ******
  ctab = stringr::str_replace_all(ctab, pattern = "\\s+", replacement = " ")

  ### ****** Trim any leading / trailing whitespace ******
  ctab = stringr::str_trim(ctab, side='both')

  ### ****** Split each line into components
  ### Since color table lines are something like "A 255 0 0" for "CLASS R G B"
  ### we will split on spaces and ask for 4 columns in the resulting matrix
  ctab = stringr::str_split_fixed(ctab, pattern = " ", 4)

  ### ****** Convert to data frame and label everything ******
  ctab = as.data.frame(ctab, stringsAsFactors = FALSE)
  colnames(ctab) = c('class','R','G','B')
  ctab$R = as.numeric(ctab$R)
  ctab$G = as.numeric(ctab$G)
  ctab$B = as.numeric(ctab$B)

  return(ctab)
}


#' Reading and processing a nunr file
#'
#' NUNR files contain neuron-specific information about the mapping of the data through the SOM.
#'
#' @param filename string specifying the file path & name of the color table file
#' @param  som_width integer, width of SOM lattice in neurons
#' @param  som_height integer, height of SOM lattice in neurons
#' @param  img_width integer, width of image cube in pixels
#' @param  img_height integer, height of image cube in pixels
#'
#' @return a list with components:
#' \itemize{
#'   \item density, a (som_height x som_width) length integer vector whose i-th element contains the number of image pixels (observations) mapped to prototype i.
#'   \item class, a (som_height x som_height) length character vector whose i-th element contains the majority label of the pixels mapped to prototype i.
#'   \item hitmap, an integer matrix of dimension (img_height, img_width) whose [i,j] entry is the (linear) index of the prototype which pixel [i,j] was mapped to.
#'   \item som_indexmap, an integer matrix of dimension (som_height, som_width) whose [i,j] entry is the linear index of the neuron at the [i,j] location in the lattice.
#' }
#'
#' Special note:  The indexing starts at the SW corner of the lattice, reading along the rows, and finishes at the NE corner of the lattice.  Thus, the first element of the density and class vectors corresponds to the prototype attached to the neuron at the SW corner of the lattice.  View som_indexmap for inspection of this.
#'
#' @examples
#' read_khoros_nunr('8class-caseI.27x27.k3.r.5000000.nunr')
#'
#' @export
read_khoros_nunr = function(filename, som_width, som_height, img_width, img_height) {

  ### ****** Read data line by line ******
  ### Each line represents information about a PE, with the first line referencing
  ### the PE in the SW corner of the lattice.  The information is in the format
  ### "PEID HITCOUNT [CLASS IMGX IMGY]
  nunr = readLines(filename)

  ### The first line contains a header of sorts.  Ignore it
  nunr = nunr[-1]

  ### Verify that the vector is of the expected length = som_width * som_height
  if(length(nunr)!=(som_width*som_height)) {
    stop('The nunr file does not have som_width * som_height lines!  Exiting.')
  }

  ### ****** Begin Processing ******

  ### First remove the PEID from the list, as we don't need it for anything
  ### To do this, locate the position of the first whitespace, and only keep
  ### everything after that
  ws_start_pos = stringr::str_locate(nunr, pattern = "\\s")[,1]
  nunr = stringr::str_sub(nunr, start = ws_start_pos)

  ### Trim up any leading whitespace in each line
  nunr = stringr::str_trim(nunr, side = 'left')

  ### Now the first element in each vector is the PE hitcount.
  ### Extract it, and adjust the strings
  ws_start_pos = stringr::str_locate(nunr, pattern = "\\s")[,1]
  pe.hits = stringr::str_sub(nunr, start = 1, end = ws_start_pos-1)
  nunr = stringr::str_sub(nunr, start = ws_start_pos)
  nunr = stringr::str_trim(nunr, side = 'both')

  ### Make sure the hitcount is numeric, and determine which PEs are live (vs. dead)
  pe.hits = as.numeric(pe.hits)
  live_pe_idx = which(pe.hits > 0)

  ### Split each element of the vector on whitespace
  ### This yields a list (of length = nunr) of character vectors
  ### The length of the vector in nunr[[i]] = 3*number of hits.
  ### Each group of 3 represents "CLASS" "imgX" "imgY"
  nunr = stringr::str_split(nunr, pattern = "\\s+")

  ### Determine the mapping label of each PE
  ### This is the majority class label of the set of points mapped to each PE
  hitclasses = lapply(nunr, function(y) y[seq(1,length(y), by=3)])
  pe.class = rep(NA, som_width*som_height)
  pe.class[live_pe_idx] = unlist(lapply(hitclasses[live_pe_idx], function(y) names(sort(table(y), decreasing = TRUE))[1]))

  ### Build a "hitmap", which is a matrix of [img_height x img_width] pixels which
  ### gives the index of the PE that each pixel is mapped to
  ### The pe index starts from 1 at the SW corner (since the nunr list is ordered that way)
  hitmap = matrix(NA, nrow = img_height, ncol = img_width)

  xy_idx = function(z) {
    x = as.numeric(z[seq(2,length(z), by=3)])
    y = as.numeric(z[seq(3,length(z), by=3)])
    return(cbind(y,x))
  }

  for(i in live_pe_idx) {
    hitmap[xy_idx(nunr[[i]])] = i
  }

  idxmap = matrix(1:(som_height*som_width), nrow=som_height, ncol=som_width, byrow=T)
  idxmap = reorder_cbl_along_height(idxmap)


  out = NULL
  out$density = pe.hits
  out$class = pe.class
  out$hitmap = hitmap
  out$som_indexmap = idxmap
  return(out)
}


#' Writing a Khoros data cube in .viff format
#'
#' Khoros data cubes contain a 1024 byte header, followed by the data cube in band sequential layout
#'
#' @param  X data matrix, number of rows = img_width * img_height, number of columns = number of image bands
#' @param  img_width integer, width of image cube in pixels
#' @param  img_height integer, height of image cube in pixels
#' @param  filepathname string, address of output file
#' @param  header_comment string, any comments about the data to include in the header
#'
#' @return None
#'
#' Special note:  The data matrix is assumed to be ordered such that the first row represents the NW pixel and last row represents the SE pixel
#'
#' @export
write_khoros_datacube = function(X, img_width = NULL, img_height = NULL, filepathname, header_comment = ' ') {

  ### If X is a vector (unlikely, unless data has dimension 1) turn it into a matrix
  if(is.vector(X)) X = as.matrix(X)

  ### If X is a matrix, the dimensions MUST be given, and they must match
  if(is.matrix(X)) {
    if(is.null(img_width) || is.null(img_height)) {stop('write_khoros_datacube:  Image dimensions must be given if input is a matrix.')}
    if(img_width * img_height != nrow(X)) {stop('write_khoros_datacube:  Input dimensions must match the number of rows of the input matrix.')}
    img_depth = ncol(X)
  }

  ### If X is a cube (3d array), we can extract the dimensions directly if needed
  x_is_cube = !is.na(dim(X)[3])
  if(x_is_cube) {
    img_depth = dim(X)[3]
    if(is.null(img_width) || is.null(img_height)) {
      img_height = dim(X)[1]
      img_width = dim(X)[2]
    }
  }

  ### Open the binary connection for writing
  con = file(filepathname, open = 'wb')

  ### Write the header
  write_khoros_header(con, imgE = 'little', imgW = img_width, imgH = img_height, imgB = img_depth, imgT = 'double', comment = header_comment)

  ### Write the data
  for(i in 1:img_depth) {

    if(is.matrix(X)) {
      writeBin(X[,i], con = con, size = 8, endian = 'little')
    }

    if(x_is_cube) {
      writeBin(c(t(X[,,i])), con = con, size = 8, endian = 'little')
    }
  }

  ### Close the connection
  close(con)
}


#' Writing a Khoros include file in ascii format
#'
#' Khoros include files are ascii files.  Each row (entry) contains an include statement of the form "include area x0 y0 x1 y1 C" where (x0,y0) and (x1,y1) are the x-y coordinates of the top left and bottom right (respectively) pixels in the defined region.  C = a class definition.
#'
#' @param  classmap character vector, length = number of pixels in image.  Each element contains a pixel label.
#' @param  inclmap boolean vector, length = number of pixels in image.  Each element defines whether the pixel is included (=TRUE) or masked (=FALSE) in the image.
#' @param  img_width integer, width of image cube in pixels
#' @param  img_height integer, height of image cube in pixels
#' @param  filepathname string, address of output file
#' @param  img_filename string, the file name of the image this include file corresponds to
#'
#' @return None
#'
#' Special note:  The vectors are assumed to be ordered such that the first element represents the NW pixel and last element represents the SE pixel
#'
#' @export
write_khoros_includefile = function(classmap, inclmap, img_width = NULL, img_height = NULL, filepathname, img_filename = ' ') {

  ### If both classmap & inclmap are vectors, they must be the same length, and the img dimensions must be given
  if(is.vector(classmap) && is.vector(inclmap)) {
    if(length(classmap) != length(inclmap)) stop('write_khoros_includefile:  classmap & inclmap must be the same dimension.')
    if(is.null(img_width) || is.null(img_height)) stop('write_khoros_includefile:  Image dimensions must be given if classmap & inclmap are vectors.')
  }


  ### If both classmap & inclmap are matricies, they must be the same dimension, and those dimensions must match the input ones
  if(is.matrix(classmap) && is.matrix(inclmap)) {
    if(any(dim(classmap) != dim(inclmap))) stop('write_khoros_includefile:  classmap & inclmap must be the same dimension.')

    if(is.null(img_width)) {
      img_width = ncol(classmap)
    } else {
      if(img_width != ncol(classmap)) {
        warning('write_khoros_includefile:  img_width does not match number of columns of classmap.  Using number of columns instead.')
        img_width = ncol(classmap)
      }
    }

    if(is.null(img_height)) {
      img_height = nrow(classmap)
    } else {
      if(img_height != nrow(classmap)) {
        warning('write_khoros_includefile:  img_height does not match number of rows of classmap.  Using number of rows instead.')
        img_height = nrow(classmap)
      }
    }

    ### For consistency, vectorize both classmap & inclmap
    classmap = c(t(classmap))
    inclmap = c(t(inclmap))
  }

  ### Total number of pixels in image
  npixels = img_width * img_height

  ### Determine unique classes given in classmap, and their pixel counts
  unq.class = sort(unique(classmap))
  k = length(unq.class)
  nk = sapply(1:k, FUN = function(z) {sum(classmap == unq.class[z])} )

  ### Open the connection to the text file for writing
  con = file(filepathname, open = 'wt')

  ### Write my header
  cat(sprintf('# Include file corresponding to %s\n',img_filename), file = con)
  cat(sprintf('# Author: Josh Taylor   %s\n',date()), file = con)
  cat(sprintf('# img_width = %d   img_height = %d\n',img_width, img_height), file = con)
  cat(sprintf('# Total pixels = %d   Unmasked = %d   Masked = %d\n', npixels, sum(inclmap == TRUE), sum(inclmap == FALSE)), file = con)
  cat(sprintf('# Class Distribution:\n'), file = con)
  for(i in 1:k) {
    cat(sprintf('#    %s = %d\n', unq.class[i], nk[i]), file = con)
  }

  ### Write the include text
  inclmap_str = rep('exclude area', npixels)
  inclmap_str[inclmap] = 'include area'
  incl_row = 1
  for(i in 1:img_height) {
    for(j in 1:img_width) {
      ### Format is "include area fromx fromy tox toy"
      cat(sprintf('%s\t%d\t%d\t%d\t%d\t%s\n', inclmap_str[incl_row], j, i, j, i, classmap[incl_row]), file = con)
      incl_row = incl_row + 1
    }
  }

  ### Close the connection
  close(con)
}


#' #' Writing a Khoros min/max table
#' #'
#' #' Minmax tables are ascii files defining the scale ranges performed internally in NeuralWare.  For learning, all data is scaled by dimension from [scale_from_min,scale_from_max] to [-1,1]
#' #'
#' #' @param  scale_from_min vector, length = dimension of data, elements contain the min value of the "scale from" range
#' #' @param  scale_from_max vector, length = dimension of data, elements contain the max value of the "scale from" range
#' #' @param  filepathname string, address of output file
#' #'
#' #' @return None
#' #'
#' #' @export
#' write_khoros_minmax = function(scale_from_min, scale_from_max, filepathname) {
#'
#'   ### The scale vectors must have the same dimension to proceed
#'   if(length(scale_from_min) != length(scale_from_max)) stop('write_khoros_minmax:  scale_from_max & scale_from_min must have the same dimension.')
#'   p = length(scale_from_min)
#'
#'   ### Specify number of entries to write per line
#'   groups_of = 8
#'   xcoord = (1:p-1) %% groups_of + 1
#'   ycoord = ceiling(1:p / groups_of)
#'
#'   ### Specify the termination characters for each entry of the min & max tables
#'   term = rep(' ',p)
#'   term[xcoord == groups_of] = '\n&'
#'   term[p] = '\n'
#'
#'   ### Open the text file for writing
#'   con = file(filepathname, open = 'wt')
#'
#'   ### Write the min portion of the minmax table
#'   for(i in 1:p) { cat(sprintf('%f%s', scale_from_min[i], term[i]), file = con) }
#'   cat(sprintf('&%f\n',0), file = con)
#'
#'   ### Write the max portion of the minmax table
#'   for(i in 1:p) { cat(sprintf('%f%s', scale_from_max[i], term[i]), file = con) }
#'   cat(sprintf('&%f\n',1), file = con)
#'
#'   ### Close the file
#'   close(con)
#' }


#' Write viff, include and minmax Khoros files for a dataset.
#'
#' This file is a pre-processing wrapper for \code{scale_khoros_datacube}, \code{scale_khoros_includefile} and \code{scale_khoros_minmax}.
#'
#' @param  X data matrix, number of rows = img_width * img_height, number of columns = number of image bands
#' @param  pxlclass character vector, number of elements = number of image pixels.  Each element contains the class label for its respective pixel.  If \code{NULL}, pixels are assumed to be unlabeled and a class of "?" will be assigned to all pixels.
#' @param  incl boolean vector, number of elements = number of image pixels.  Each element defines whether the respective pixel is included (=TRUE) or excluded (=FALSE) for image processing.  If arrange_by_class = TRUE this will be automatically determined.  If arrange_by_class = FALSE and inclmap = \code{NULL}, all pixels are assumed included.
#' @param  img_width integer, width of image cube in pixels.  img_height is determined internally.
#' @param  img_height integer, height of image cube in pixels.
#' @param  scale_from_min vector, length = dimension of data, elements contain the min value of the "scale from" range
#' @param  scale_from_max vector, length = dimension of data, elements contain the max value of the "scale from" range
#' @param  filenameroot string, defines the naming convention for the suite of files.  Example:  "8class-caseI" will produce files "8class-caseI.{viff,incl,minmax}"
#' @param  directory string, defines the directory the target files will be saved in
#' @param  arrange_by_class boolean, should the the data matrix be grouped by the input classes before writing?  This ensures all pixels belonging to the same class are near each other in the output image.  If FALSE, the data matrix will be written as is.
#' @param  NA_value double, defines the value used for the padding introduced if arrange_by_class = TRUE
#'
#' @return None
#'
#' Notes:
#' \itemize{
#' \item If arrange_by_class = TRUE, img_height will be determined automatically.  Otherwise, it is assumed the data matrix is already pre-arranged and img_height will be derived as nrow(X) / img_width.
#' }
#'
#' @export
write_khoros_files = function(X, pxlclass=NULL, incl = NULL, img_width, img_height = NULL, scale_from_min, scale_from_max, filenameroot, directory = getwd(), arrange_by_class = TRUE, NA_value = -12345.6789) {

  ### Grab dimension of data
  p = ncol(X)

  ### Process file names.  If the input directory is not in "/blah/" format, with the "/" at the end, add it.
  ### Then create the full path names for the .viff, .incl & .minmax files
  if(stringr::str_sub(directory, stringr::str_length(directory)) != "/") directory = stringr::str_c(directory,"/")
  fn_viff = stringr::str_c(directory,filenameroot,'.viff')
  fn_incl = stringr::str_c(directory,filenameroot,'.incl')
  fn_minmax = stringr::str_c(directory,filenameroot,'.minmax')

  ### If no class labels were given, just assume all are '?'
  if(is.null(pxlclass)) {
    pxlclass = rep('?', nrow(X))
    } else {
      allowed_classes = c(LETTERS,letters)
      unq.classes = sort(unique(pxlclass))

      if(length(unq.classes) > 52) stop('write_khoros_files:  you may have no more than 52 classes in your data.')

      for(i in 1:length(unq.classes)) {
        if(!(unq.classes[i] %in% allowed_classes) && unq.classes[i]!='?') {
          warning(sprintf('Converting class %s to %s', unq.classes[i], allowed_classes[i]))
          pxlclass[pxlclass == unq.classes[i]] = allowed_classes[i]
        }
      }
    }

  ### If no incl map was given, assume everything is included
  if(is.null(incl)) incl = rep(TRUE, nrow(X))

  if(arrange_by_class == FALSE) {
    X_out = X
    pxlclass_out = pxlclass
    incl_out = incl
  } else {
    ### If we are to arrange the image by class we need to adjust the size of X & pxlclass
    ### Determine the new dimensions and fill up the matrix
    unq.class = sort(unique(pxlclass))
    k = length(unq.class)
    nk = sapply(1:k, FUN = function(z) {sum(pxlclass == unq.class[z])} )
    rows_per_k = ceiling(nk / img_width)
    padding_per_k = rows_per_k*img_width - nk
    img_height = sum(rows_per_k)
    npixels = img_width * img_height

    X_out = matrix(NA_value, nrow = npixels, ncol = p)
    pxlclass_out = rep("?",npixels)
    incl_out = rep(FALSE,npixels)

    ### Fill up the expanded data matrix, class map and include map
    startrow = 1
    for(i in 1:k) {
      endrow = startrow + nk[i] - 1
      X_out[startrow:endrow,] = X[pxlclass == unq.class[i],]
      pxlclass_out[startrow:endrow] =  unq.class[i]
      incl_out[startrow:endrow] = TRUE
      startrow = endrow + 1 + padding_per_k[i]
    }
  }

  ### Write some summary information about the image cube

  ### The corner values (all dimensions)
  cat(sprintf('Values by dimension:\n'))
  cat(sprintf('NW corner of cube = %s\n', paste(sprintf('%.4g',X_out[1,]), collapse = ' ')))
  cat(sprintf('NE corner of cube = %s\n', paste(sprintf('%.4g',X_out[img_width,]), collapse = ' ')))
  cat(sprintf('SW corner of cube = %s\n', paste(sprintf('%.4g',X_out[(img_height-1)*img_width+1,]), collapse = ' ')))
  cat(sprintf('SE corner of cube = %s\n', paste(sprintf('%.4g',X_out[img_height*img_width,]), collapse = ' ')))

  ### The masked 4-number summary, by dimension
  cat(sprintf('\n'))
  cat(sprintf('Summary statistics by dimension:\n'))
  cat(sprintf('Masked mean = %s\n', paste(sprintf('%.4g',apply(X_out[incl_out,],2,mean)), collapse = ' ')))
  cat(sprintf('Masked var = %s\n', paste(sprintf('%.4g',apply(X_out[incl_out,],2,var)), collapse = ' ')))
  cat(sprintf('Masked min = %s\n', paste(sprintf('%.4g',apply(X_out[incl_out,],2,min)), collapse = ' ')))
  cat(sprintf('Masked max = %s\n', paste(sprintf('%.4g',apply(X_out[incl_out,],2,max)), collapse = ' ')))
  cat(sprintf('\n'))
  cat(sprintf('Overall mean = %s\n', paste(sprintf('%.4g',apply(X_out,2,mean)), collapse = ' ')))
  cat(sprintf('Overall var = %s\n', paste(sprintf('%.4g',apply(X_out,2,var)), collapse = ' ')))
  cat(sprintf('Overall min = %s\n', paste(sprintf('%.4g',apply(X_out,2,min)), collapse = ' ')))
  cat(sprintf('Overall max = %s\n', paste(sprintf('%.4g',apply(X_out,2,max)), collapse = ' ')))

  ### Write the data cube
  write_khoros_datacube(X = X_out, img_width = img_width, img_height = img_height, filepathname = fn_viff, header_comment = filenameroot)

  ### Write the include file
  write_khoros_includefile(classmap = pxlclass_out, inclmap = incl_out, img_width = img_width, img_height = img_height, filepathname = fn_incl, img_filename = filenameroot)

  ### Write the minmax table
  if(length(scale_from_min) != length(scale_from_max)) stop('write_khoros_files:  scale_from_min & scale_from_max must have the same dimension.')
  if(length(scale_from_min) == 1) scale_from_min = rep(scale_from_min, p)
  if(length(scale_from_max) == 1) scale_from_max = rep(scale_from_max, p)

  write_khoros_minmax(scale_from_min = scale_from_min, scale_from_max = scale_from_max, filepathname = fn_minmax)
}


#' Writing a Khoros data cube header
#'
#' Khoros data cubes contain a 1024 byte proprietary header.
#'
#' @param  fid connection to binary file for writing
#' @param  imgE string, the endian-ness to write in.  Deprecated -- all files are written in little endian
#' @param  imgW integer, width of image cube in pixels
#' @param  imgH integer, height of image cube in pixels
#' @param  imgB integer, number of image bands
#' @param  imgT string, type of data to write.  Can be 'double','numeric' (float),'integer' (16-bit signed integer)
#' @param  comment string, any comments about the data to include in the header
#'
#' @return None
#'
#' Special note:  The data matrix is assumed to be ordered such that the first row represents the NW pixel and last row represents the SE pixel
#'
#' @export
write_khoros_header = function(fid,imgE,imgW,imgH,imgB,imgT = 'double',comment = ' ') {
# % AUTHOR:           Patrick O'Driscoll - po2@rice.edu
# % LAST UPDATED:     2017/05/24
# %
# % FUNCTION:
# %   Write the kohros viff file header. This header is 1024 bytes, and is
# %   is used to natively interface with khoros, or visiquest.
# %
# % Syntax:
# %   viffHead(fid,imgW,imgH,imgB,imgT)
# %
# % INPUTS:
# %   fid : file id produced from fopen()
# %   imgE: image data endianness
# %       'b': big-endian byte ordering
# %       'l': little-endian byte ordering
# %   imgW: image width in pixels
# %   imgH: image height in pixels
# %   imgB: number of image bands
# %   imgT: image data khoros type
# %       'bit'   : bit
# %       'byte'  : byte
# %       'ubyte' : unsigned byte
# %       'short' : short
# %       'ushort': unsigned short
# %       'int'   : int
# %       'uint'  : unsigned int
# %       'long'  : long
# %       'ulong' : unsigned long
# %       'float' : float
# %       'double': double
# %       'comp'  : complex
# %     'dcomp' : double complex
# % comment: Comment string. Must be less than 512 char
# %
# % OUTPUS:
# %   Outputs are directly written to the fid file.
# %
# % NOTES:
# %   We mimic the C structure found at:
# %   http://www.fileformat.info/format/viff/egff.htm
# % typedef struct _ViffHeader
# % {
# % CHAR  FileId;            /* Khoros file ID value (always ABh)*/
# % CHAR  FileType;          /* VIFF file ID value (always 01h) */
# % CHAR  Release;           /* Release number (1) */
# % CHAR  Version;           /* Version number (0) */
# % CHAR  MachineDep;        /* Machine dependencies indicator */
# % CHAR  Padding[3];        /* Structure alignment padding (always 00h)*/
# % CHAR  Comment[512];      /* Image comment text */
# % DWORD NumberOfRows;      /* Length of image rows in pixels */
# % DWORD NumberOfColumns;   /* Length of image columns in pixels */
# % DWORD LengthOfSubrow;    /* Size of any sub-rows in the image */
# % LONG  StartX;            /* Left-most display starting position */
# % LONG  StartY;            /* Upper-most display starting position */
# % FLOAT XPixelSize;        /* Width of pixels in meters */
# % FLOAT YPixelSize;        /* Height of pixels in meters */
# % DWORD LocationType;      /* Type of pixel addressing used */
# % DWORD LocationDim;       /* Number of location dimensions */
# % DWORD NumberOfImages;    /* Number of images in the file */
# % DWORD NumberOfBands;     /* Number of bands (color channels) */
# % DWORD DataStorageType;   /* Pixel data type */
# % DWORD DataEncodingScheme;/* Type of data compression used */
# % DWORD MapScheme;         /* How map is to be interpreted */
# % DWORD MapStorageType;    /* Map element data type */
# % DWORD MapRowSize;        /* Length of map rows in pixels */
# % DWORD MapColumnSize;     /* Length of map columns in pixels */
# % DWORD MapSubrowSize;     /* Size of any subrows in the map */
# % DWORD MapEnable;         /* Map is optional or required */
# % DWORD MapsPerCycle;      /* Number of different   maps present */
# % DWORD ColorSpaceModel;   /* Color model used to represent image */
# % DWORD ISpare1;           /* User-defined field */
# % DWORD ISpare2;           /* User-defined field */
# % FLOAT FSpare1;           /* User-defined field */
# % FLOAT FSpare2;           /* User-defined field */
# % CHAR  Reserve[404];      /* Padding */
# % } VIFFHEADER;

    imgW = as.integer(imgW)
    imgH = as.integer(imgH)
    imgB = as.integer(imgB)

    # check comment size
    if(stringr::str_length(comment) > 512) {
        stop('Comment is too long.  Must be <= 512 characters.')
    } else {
        comment = stringr::str_pad(comment, width=512, side = 'right')
        #commentPadding = 512-stringr::str_length(comment);
    }



    # print header                                           #Val  #B  #tot reason       comment
    writeBin(171L, con = fid, size = 1, endian = 'little')    #ab   1   1    FileId
    writeBin(001L, con = fid, size = 1, endian = 'little')    #01   1   2    FileType
    writeBin(001L, con = fid, size = 1, endian = 'little')    #01   1   3    Release
    writeBin(003L, con = fid, size = 1, endian = 'little')    #03   1   4    Version

    # Machine endianness
    if(imgE == 'big') {
        writeBin(002L, con = fid, size = 1, endian = 'little')
    } else if(imgE == 'little') {
        writeBin(008L, con = fid, size = 1, endian = 'little')
    } else {
        stop('viffHead: unknown imgE argument')
    }

    for(ii in 1:3) {
        writeBin(000L, con = fid, size = 1, endian = 'little') #00   3   8    Padding[3]
    }


    #                                 %00   512 520  Comment[512]
    # print('hello!')
    # for(ii in 1:512) {
    #     writeBin(stringr::str_sub(comment,ii,ii), con = fid, size = 1, endian = 'little')
    # }
    # for(ii in 1:commentPadding) {
    #     writeBin(000L, con = fid, size = 1, endian = 'little')
    # }

    # for(ii in 1:512) {
    #     writeBin(0L, con = fid, size = 1, endian = 'little')
    # }

    writeBin(stringr::str_sub(comment,1,511), con = fid, size = 1, endian = 'little')

    writeBin(imgW, con = fid, size = 4, endian = 'little')      #??   4   524  NumberOfRows
    writeBin(imgH, con = fid, size = 4, endian = 'little')      #??   4   528  NumberOfColumns
    writeBin(0000L, con = fid, size = 4, endian = 'little')      #00   4   532  LengthOfSubrow
    for(ii in 1:4) {
      writeBin(255L, con = fid, size = 1, endian = 'little')     #ff   4   536  StartX       % ff ff ff ff
    }
    for(ii in 1:4) {
      writeBin(255L, con = fid, size = 1, endian = 'little')     #ff   4   540  StartY       % ff ff ff ff
    }

    writeBin(000L, con = fid, size = 2, endian = 'little')       #0000 4   544  XPixelSize   % 00 00 80 3f
    writeBin(128L, con = fid, size = 1, endian = 'little')       #80
    writeBin(063L, con = fid, size = 1, endian = 'little')       #3f
    writeBin(000L, con = fid, size = 2, endian = 'little')       #0000 4   548  YPixelSize   % 00 00 80 3f
    writeBin(128L, con = fid, size = 1, endian = 'little')       #80
    writeBin(063L, con = fid, size = 1, endian = 'little')       #3f
    writeBin(001L, con = fid, size = 4, endian = 'little')       #01   4   552  LocationType % implicit
    writeBin(000L, con = fid, size = 4, endian = 'little')       #00   4   556  LocationDim  % implicit
    writeBin(001L, con = fid, size = 4, endian = 'little')       #01   4   560  NumberOfImages
    writeBin(imgB, con = fid, size = 4, endian = 'little')      #??   4   564  NumberOfBands


    switch(imgT,                #??   4   568  DataStorageType
        'bit' = writeBin(00L, con = fid, size = 4, endian = 'little'),      # 00 -> bit
        'byte' = writeBin(01L, con = fid, size = 4, endian = 'little'),     # 01 -> byte
        'ubyte' = writeBin(01L, con = fid, size = 4, endian = 'little'),    # 01 -> unsigned byte
        'short' = writeBin(02L, con = fid, size = 4, endian = 'little'),    # 02 -> short
        'ushort' = writeBin(02L, con = fid, size = 4, endian = 'little'),   # 02 -> unsigned short
        'int' = writeBin(04L, con = fid, size = 4, endian = 'little'),      # 04 -> int
        'uint' = writeBin(04L, con = fid, size = 4, endian = 'little'),     # 04 -> unsigned int
        'long' = writeBin(04L, con = fid, size = 4, endian = 'little'),     # 04 -> long
        'ulong' = writeBin(04L, con = fid, size = 4, endian = 'little'),    # 04 -> unsigned long
        'float' = writeBin(05L, con = fid, size = 4, endian = 'little'),    # 05 -> float
        'double' = writeBin(09L, con = fid, size = 4, endian = 'little'),   # 09 -> double
        'comp' = writeBin(06L, con = fid, size = 4, endian = 'little'),     # 06 -> complex
        'dcomp' = writeBin(10L, con = fid, size = 4, endian = 'little'),    # 0a -> double complex
        stop('writeViffHead: unknown imgT argument')
    )

    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   572  DataEncodingScheme % none
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   576  MapScheme          % each band is img
    writeBin(001L, con = fid, size = 4, endian = 'little')    # 01   4   580  MapStorageType
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   584  MapRowSize
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   588  MapColumnSize
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   592  MapSubrowSize
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   596  MapEnable
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   600  MapsPerCycle
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   604  ColorSpaceModel    % none
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   608  ISpare1
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   612  ISpare2
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   616  FSpare1
    writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   620  FSpare2
    for(ii in 1:404) {
      writeBin(000L, con = fid, size = 1, endian = 'little')   # 00   404 1024 Padding
    }


}


#' Write a Khoros KRGB header
#'
#' @description If a connection to a binary writeable file is open, this function will write the header required
#' for Khoros to recognize the cube as KRGB formatted.
#' @param fid a connection to a binary file, see \code{?file} for more info.
#' @param imgE the file endian-ness, can be 'little' or 'big'
#' @param imgW the image width, in pixels
#' @param imgH the image height, in pixels
#' @param comment optional, any comment string the user wishes to add to the header information. Default = ' ' adds nothing. This must be < 512 characters.
#' @return nothing
#' @details This is translated from Khoros I/O manipulation originally written in Matlab by Patrick O'Driscoll.
#' @export
write_khoros_header_KRGB = function(fid,imgE,imgW,imgH,comment = ' ') {
  # % AUTHOR:           Patrick O'Driscoll - po2@rice.edu
  # % LAST UPDATED:     2017/05/24
  # %
  # % FUNCTION:
  # %   Write the kohros viff file header. This header is 1024 bytes, and is
  # %   is used to natively interface with khoros, or visiquest.
  # %
  # % Syntax:
  # %   viffHead(fid,imgW,imgH,imgB,imgT)
  # %
  # % INPUTS:
  # %   fid : file id produced from fopen()
  # %   imgE: image data endianness
  # %       'b': big-endian byte ordering
  # %       'l': little-endian byte ordering
  # %   imgW: image width in pixels
  # %   imgH: image height in pixels
  # %   imgB: number of image bands
  # %   imgT: image data khoros type
  # %       'bit'   : bit
  # %       'byte'  : byte
  # %       'ubyte' : unsigned byte
  # %       'short' : short
  # %       'ushort': unsigned short
  # %       'int'   : int
  # %       'uint'  : unsigned int
  # %       'long'  : long
  # %       'ulong' : unsigned long
  # %       'float' : float
  # %       'double': double
  # %       'comp'  : complex
  # %     'dcomp' : double complex
  # % comment: Comment string. Must be less than 512 char
  # %
  # % OUTPUS:
  # %   Outputs are directly written to the fid file.
  # %
  # % NOTES:
  # %   We mimic the C structure found at:
  # %   http://www.fileformat.info/format/viff/egff.htm
  # % typedef struct _ViffHeader
  # % {
  # % CHAR  FileId;            /* Khoros file ID value (always ABh)*/
  # % CHAR  FileType;          /* VIFF file ID value (always 01h) */
  # % CHAR  Release;           /* Release number (1) */
  # % CHAR  Version;           /* Version number (0) */
  # % CHAR  MachineDep;        /* Machine dependencies indicator */
  # % CHAR  Padding[3];        /* Structure alignment padding (always 00h)*/
  # % CHAR  Comment[512];      /* Image comment text */
  # % DWORD NumberOfRows;      /* Length of image rows in pixels */
  # % DWORD NumberOfColumns;   /* Length of image columns in pixels */
  # % DWORD LengthOfSubrow;    /* Size of any sub-rows in the image */
  # % LONG  StartX;            /* Left-most display starting position */
  # % LONG  StartY;            /* Upper-most display starting position */
  # % FLOAT XPixelSize;        /* Width of pixels in meters */
  # % FLOAT YPixelSize;        /* Height of pixels in meters */
  # % DWORD LocationType;      /* Type of pixel addressing used */
  # % DWORD LocationDim;       /* Number of location dimensions */
  # % DWORD NumberOfImages;    /* Number of images in the file */
  # % DWORD NumberOfBands;     /* Number of bands (color channels) */
  # % DWORD DataStorageType;   /* Pixel data type */
  # % DWORD DataEncodingScheme;/* Type of data compression used */
  # % DWORD MapScheme;         /* How map is to be interpreted */
  # % DWORD MapStorageType;    /* Map element data type */
  # % DWORD MapRowSize;        /* Length of map rows in pixels */
  # % DWORD MapColumnSize;     /* Length of map columns in pixels */
  # % DWORD MapSubrowSize;     /* Size of any subrows in the map */
  # % DWORD MapEnable;         /* Map is optional or required */
  # % DWORD MapsPerCycle;      /* Number of different   maps present */
  # % DWORD ColorSpaceModel;   /* Color model used to represent image */
  # % DWORD ISpare1;           /* User-defined field */
  # % DWORD ISpare2;           /* User-defined field */
  # % FLOAT FSpare1;           /* User-defined field */
  # % FLOAT FSpare2;           /* User-defined field */
  # % CHAR  Reserve[404];      /* Padding */
  # % } VIFFHEADER;

  imgW = as.integer(imgW)
  imgH = as.integer(imgH)
  #imgB = as.integer(imgB)

  # check comment size
  if(stringr::str_length(comment) > 512) {
    stop('Comment is too long.  Must be <= 512 characters.')
  } else {
    comment = stringr::str_pad(comment, width=512, side = 'right')
  }



  # print header                                           #Val  #B  #tot reason       comment
  writeBin(171L, con = fid, size = 1, endian = 'little')    #ab   1   1    FileId
  writeBin(001L, con = fid, size = 1, endian = 'little')    #01   1   2    FileType
  writeBin(001L, con = fid, size = 1, endian = 'little')    #01   1   3    Release
  writeBin(003L, con = fid, size = 1, endian = 'little')    #03   1   4    Version

  # Machine endianness
  if(imgE == 'big') {
    writeBin(002L, con = fid, size = 1, endian = 'little')
  } else if(imgE == 'little') {
    writeBin(008L, con = fid, size = 1, endian = 'little')
  } else {
    stop('viffHead: unknown imgE argument')
  }

  for(ii in 1:3) {
    writeBin(000L, con = fid, size = 1, endian = 'little') #00   3   8    Padding[3]
  }


  writeBin(stringr::str_sub(comment,1,511), con = fid, size = 1, endian = 'little')

  writeBin(imgW, con = fid, size = 4, endian = 'little')      #??   4   524  NumberOfRows
  writeBin(imgH, con = fid, size = 4, endian = 'little')      #??   4   528  NumberOfColumns
  writeBin(0000L, con = fid, size = 4, endian = 'little')      #00   4   532  LengthOfSubrow
  for(ii in 1:4) {
    writeBin(255L, con = fid, size = 1, endian = 'little')     #ff   4   536  StartX       % ff ff ff ff
  }
  for(ii in 1:4) {
    writeBin(255L, con = fid, size = 1, endian = 'little')     #ff   4   540  StartY       % ff ff ff ff
  }

  writeBin(000L, con = fid, size = 2, endian = 'little')       #0000 4   544  XPixelSize   % 00 00 80 3f
  writeBin(128L, con = fid, size = 1, endian = 'little')       #80
  writeBin(063L, con = fid, size = 1, endian = 'little')       #3f
  writeBin(000L, con = fid, size = 2, endian = 'little')       #0000 4   548  YPixelSize   % 00 00 80 3f
  writeBin(128L, con = fid, size = 1, endian = 'little')       #80
  writeBin(063L, con = fid, size = 1, endian = 'little')       #3f
  writeBin(001L, con = fid, size = 4, endian = 'little')       #01   4   552  LocationType % implicit
  writeBin(000L, con = fid, size = 4, endian = 'little')       #00   4   556  LocationDim  % implicit
  writeBin(001L, con = fid, size = 4, endian = 'little')       #01   4   560  NumberOfImages
  imgB = as.integer(3) ## always 3 bands for KRGB viffs
  writeBin(imgB, con = fid, size = 4, endian = 'little')      #??   4   564  NumberOfBands

  imgT = 'ubyte' ## KRGB viff cubes must be unsigned byte
  switch(imgT,                #??   4   568  DataStorageType
         'bit' = writeBin(00L, con = fid, size = 4, endian = 'little'),      # 00 -> bit
         'byte' = writeBin(01L, con = fid, size = 4, endian = 'little'),     # 01 -> byte
         'ubyte' = writeBin(01L, con = fid, size = 4, endian = 'little'),    # 01 -> unsigned byte
         'short' = writeBin(02L, con = fid, size = 4, endian = 'little'),    # 02 -> short
         'ushort' = writeBin(02L, con = fid, size = 4, endian = 'little'),   # 02 -> unsigned short
         'int' = writeBin(04L, con = fid, size = 4, endian = 'little'),      # 04 -> int
         'uint' = writeBin(04L, con = fid, size = 4, endian = 'little'),     # 04 -> unsigned int
         'long' = writeBin(04L, con = fid, size = 4, endian = 'little'),     # 04 -> long
         'ulong' = writeBin(04L, con = fid, size = 4, endian = 'little'),    # 04 -> unsigned long
         'float' = writeBin(05L, con = fid, size = 4, endian = 'little'),    # 05 -> float
         'double' = writeBin(09L, con = fid, size = 4, endian = 'little'),   # 09 -> double
         'comp' = writeBin(06L, con = fid, size = 4, endian = 'little'),     # 06 -> complex
         'dcomp' = writeBin(10L, con = fid, size = 4, endian = 'little'),    # 0a -> double complex
         stop('writeViffHead: unknown imgT argument')
  )

  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   572  DataEncodingScheme % none
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   576  MapScheme          % each band is img
  writeBin(001L, con = fid, size = 4, endian = 'little')    # 01   4   580  MapStorageType
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   584  MapRowSize
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   588  MapColumnSize
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   592  MapSubrowSize
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   596  MapEnable
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   600  MapsPerCycle
  writeBin(001L, con = fid, size = 4, endian = 'little')    # 00   4   604  ColorSpaceModel    % none
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   608  ISpare1
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   612  ISpare2
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   616  FSpare1
  writeBin(000L, con = fid, size = 4, endian = 'little')    # 00   4   620  FSpare2
  for(ii in 1:404) {
    writeBin(000L, con = fid, size = 1, endian = 'little')   # 00   404 1024 Padding
  }
}


#' Write a 3-band RGB array as a Khoros formatted KRGB .viff cube
#'
#' @param rgb_img a 3-band RGB array, each element in [0-255]
#' @param filename full file path to save the resulting .viff
#' @return nothing
#' @details The image width and height will be inferred from the dimensions of \code{rgb_img}.
#' A call to \code{file()} is made to open a binary file connection, \code{write_khoros_KRGB_header} is called to write the
#' appropriate header, and then the integer RGB codes are written.
#' @export
write_khoros_KRGB = function(rgb_img, filename) {
  fid = file(filename, open = 'wb')
  write_khoros_header_KRGB(fid = fid, imgE = "little", imgW = ncol(rgb_img), imgH = nrow(rgb_img))
  writeBin(object = as.integer(t(rgb_img[,,1])), con = fid, size = 1, endian = 'little')
  writeBin(object = as.integer(t(rgb_img[,,2])), con = fid, size = 1, endian = 'little')
  writeBin(object = as.integer(t(rgb_img[,,3])), con = fid, size = 1, endian = 'little')
  close(fid)
}



#' Read a the min/max mapping stored in a .nna file
#'
#' @param path_to_nna string specifying the file path & name of the nna file
#' @param img_z the number of bands in the image that this nna corresponds to
#' @export
read_khoros_nna = function(path_to_nna, img_z) {
  infile = readr::read_lines(file = path_to_nna)

  ## Remove any leading or trailing whitespace from lines
  infile = stringr::str_trim(infile, side="both")

  ## Remove any lines with comments
  hash_pos = stringr::str_locate(infile, "#")[,"start"]
  for(i in 1:length(infile)) {
    if(is.na(hash_pos[i])) next
    if(hash_pos[i]==1) infile[i] = ""
    else infile[i] = stringr::str_sub(infile[i], start = 1, end = hash_pos[i]-1)
  }

  ## Replace any & characters with nothing
  infile = stringr::str_replace_all(infile, pattern = "&", replacement = "")

  ## Replace any duplicate repeatitive whitespace with single whitespace
  infile = stringr::str_replace_all(infile, pattern = "\\s+", replacement = " ")

  ## Remove any leading or trailing whitespace from lines
  infile = stringr::str_trim(infile, side="both")

  ## Remove any empty lines
  infile = infile[stringr::str_length(infile) > 0]

  ## Split on whitespace
  infile = unlist(stringr::str_split(infile, pattern = "\\s", simplify = F))

  ## Use length of line and network input dimension to determine network output dimension
  len = length(infile)
  output_dim = len/2 - img_z

  ## Read the 1st set of <input_dim> bounds as lower bounds
  lb = infile[1:img_z]
  ub = infile[(img_z+output_dim+1):(len - output_dim)]

  out = NULL
  out$min = as.numeric(lb)
  out$max = as.numeric(ub)
  return(out)
}

#' Read a the min/max mapping stored in a .nna file
#'
#' @param path_to_nna string specifying the file path & name of the nna file
#' @param img_z the number of bands in the image that this nna corresponds to
#' @export
read_nna = function(path_to_nna, img_z) {

  ## Make sure nna_filepath exists and is readable
  if(!file.exists(path_to_nna)) stop(sprintf("File %s does not exist.",path_to_nna))
  if(file.access(path_to_nna, mode = 4) == -1) stop(sprintf("File %s is not readable. Check permissions.",path_to_nna))

  ## Read the ascii text from the .nna file into a string
  nna = readr::read_file(file = path_to_nna)

  ## Split on newline characters
  nna = stringr::str_split(nna, pattern = "\\n")
  nna = unlist(nna)

  ## Remove any duplicate whitespace
  nna = stringr::str_replace_all(nna, pattern = "\\s+", replacement = " ")

  ## Trim any leading/trailing whitespace
  nna = stringr::str_trim(nna, side = "both")

  ## Remove any comment lines that begin with "#"
  comment_lines = which(stringr::str_sub(nna, start = 1, end = 1) == "#")
  if(length(comment_lines) > 0) {
    nna = nna[-comment_lines]
  }



  ## Remove any empty lines
  empty_lines = which(stringr::str_length(nna) == 0)
  if(length(empty_lines) > 0) {
    nna = nna[-empty_lines]
  }

  ## Replace any "&" with NULL
  nna = stringr::str_replace_all(nna, pattern = "&", replacement = "")

  ## Split on whitespace
  nna = unlist(stringr::str_split(nna, pattern = "\\s+"))

  ## Check the following
  if(length(nna) < 2*img_z) {
    cat(sprintf("Current nna string:\n"))
    print(nna)
    stop("nna file should contain at least 2*img_z elements.")
  }

  if( ((length(nna) - 2*img_z) %% 2) != 0 ) {
    cat(sprintf("Current nna string:\n"))
    print(nna)
    stop("cannot read nna file format. check.")
  }

  ## Determine the number of "outputs" in the network that the nna was used for
  ## This should correspond to whatever was set with the "-O " flag in anncfg.exe
  ## length(nna) should = 2*img_z + 2*num_outputs
  num_outputs = (length(nna) - 2*img_z)/2

  ## Convert the nna to numeric
  nna = as.numeric(nna)

  ## Extract the 1st set of numbers that refer to the image bands
  nna_min = nna[1:img_z]

  ## Extract the 2nd set of numbers that refer to the image bands
  nna_max = nna[(img_z + num_outputs + 1):(img_z + num_outputs + img_z)]

  ## Assemble into list for return
  out = NULL
  out$min = nna_min
  out$max = nna_max
  return(out)
}

#' Write a nna (minmax table)
#'
#' @param path_to_nna string specifying the file path & name of the nna file
#' @param input_min vector of min range of network inputs (by dim)
#' @param input_max vector of max range of network inputs (by dim)
#' @param output_min vector of min range of network outputs
#' @param output_max vector of max range of network outputs
#' @param group_size size of groups for each line of the nna file
#' @export
write_khoros_nna = function(path_to_nna, input_min, input_max, output_min, output_max, group_size = 5) {

  ## Ensure all the dimensions line up
  if(length(input_min) != length(input_max)) stop("length(input_min) != length(input_max)")
  if(length(output_min) != length(output_max)) stop("length(output_min) != length(output_max)")

  con = file(path_to_nna, open="wt")

  for(i in 1:length(input_min)) {
    cat(sprintf("%g",input_min[i]), file = con)
    if(i %% group_size == 0 && i < length(input_min)) {
      cat(sprintf("\n&"), file=con)
    } else {
      cat(sprintf(" "), file=con)
    }
  }

  cat(sprintf("\n&"), file=con)
  for(i in 1:length(output_min)) {
    cat(sprintf("%g",output_min[i]), file=con)
    if(i %% group_size == 0 && i < length(output_min)) {
      cat(sprintf("\n&"), file=con)
    } else {
      cat(sprintf(" "), file=con)
    }
  }
  cat(sprintf("\n"), file=con)

  for(i in 1:length(input_max)) {
    cat(sprintf("%g",input_max[i]), file=con)
    if(i %% group_size == 0 && i < length(input_max)) {
      cat(sprintf("\n&"), file=con)
    } else {
      cat(sprintf(" "), file=con)
    }
  }

  cat(sprintf("\n&"), file=con)
  for(i in 1:length(output_max)) {
    cat(sprintf("%g",output_max[i]), file=con)
    if(i %% group_size == 0 && i < length(output_max)) {
      cat(sprintf("\n&"), file=con)
    } else {
      cat(sprintf(" "), file=con)
    }
  }

  close(con)
}


#' View a color table
#'
#' @description This is a helper function to provide a quick visualization of the labels and their associated colors that are defined
#' in an input color table.
#' @param ctab the color table dataframe to view. Must have fields  \code{$class}, \code{$R}, \code{$G}, \code{$B}.
#' @param label.cex the size of labels, as plotted on the visual color grid
#' @param nrows_in_display sets the number of rows in the visualized color table. Default = NULL invokes automatic generation of this value,
#' with an attempt to make the resulting color grid as square as possible.
#' @return nothing, only used for visualization
#' @export
display_ctab = function(ctab, label.cex = 0.9, nrows_in_display = NULL) {

  ### Dimensions of display table
  n = nrow(ctab)

  if(is.null(nrows_in_display)) {
    xdim = floor(sqrt(n))
    ydim = ceiling(n / xdim)
  } else {
    xdim = ceiling(n / nrows_in_display)
    ydim = ceiling(n / xdim)
  }

  ### x & y coordinates of center squares
  xcoord = 1:xdim - 0.5
  ycoord = ydim:1 - 0.5
  xy = as.matrix(expand.grid(xcoord, ycoord))
  xy = xy[1:n,]

  ### Colors of blocks from color table
  block.colors = rgb(red = ctab$R, green = ctab$G, blue = ctab$B, maxColorValue = 255)

  ### The text color of the labels is dependent on the corresponding block color
  ### Default text color is black, but if the block is too dark (toward black)
  ### the text should be white to be readable.
  text.colors = rep("black", times = n)
  for(i in 1:n) {
    if(RGB_exists(newcolor = ctab[i, 2:4], existingRGB = matrix(0,1,3), tolerance = 150)) {
      text.colors[i] = "white"
    }
  }


  par(mar = rep(0,4), oma = rep(0,4), bty="n", xaxs = "i", yaxs = "i")
  plot(x = c(0, xdim), y = c(0, ydim), type="n", asp = 1, axes = F)
  rect(xleft = xy[,1]-0.5, ybottom = xy[,2] - 0.5, xright = xy[,1] + 0.5, ytop = xy[,2] + 0.5,
       col = block.colors, border = NA)
  text(x = xy[,1], y = xy[,2], labels = ctab$class, cex = label.cex , offset = 0, col = text.colors)

}



#' Write a color table to file
#'
#' @description Given an color table, write its contents as a text file, with NeuroScope formatting (i.e., "color_table" and "end color_table" tags will be appended).
#' @param ctab the color table dataframe to write Must have fields  \code{$class}, \code{$R}, \code{$G}, \code{$B}.
#' @param output_dir the directory where the file will be written
#' @param filename the output filename
#' @export
write_ctab = function(ctab, output_dir, filename) {
  if(stringr::str_sub(output_dir, -1, -1) != "/") {
    output_dir = paste(output_dir, "/", sep = "")
  }
  filepathname = paste(output_dir, filename, sep = "")
  cn = file(filepathname, open = "wt")
  cat("color_table\n", file = cn)
  for(i in 1:nrow(ctab)) {
    cat(sprintf("\t%s\t%d\t%d\t%d\n", ctab[i,1], ctab[i,2], ctab[i,3], ctab[i,4]), file = cn)
  }
  cat("end color_table\n", file = cn)
  close(cn)
}

